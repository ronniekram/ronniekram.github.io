(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react'), require('shallowequal'), require('lodash.isequal')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react', 'shallowequal', 'lodash.isequal'], factory) :
  (factory((global.reactHooksLib = {}),global.react,global.shallowequal,global.deepEqual));
}(this, (function (exports,React,shallowEqual,deepEqual) {
  var React__default = 'default' in React ? React['default'] : React;
  shallowEqual = shallowEqual && shallowEqual.hasOwnProperty('default') ? shallowEqual['default'] : shallowEqual;
  deepEqual = deepEqual && deepEqual.hasOwnProperty('default') ? deepEqual['default'] : deepEqual;

  var useToggle = function (initial) {
    if ( initial === void 0 ) initial = false;

    var ref = React.useState(initial);
    var on = ref[0];
    var setToggle = ref[1];
    return {
      on: on,
      set: setToggle,
      reset: function () { return setToggle(initial); },
      toggle: function () { return setToggle(function (prev) { return !prev; }); }
    };
  };

  var add = function (value) { return function (prev) { return prev + value; }; };

  var useCounter = function (initial) {
    if ( initial === void 0 ) initial = 0;

    var ref = React.useState(initial);
    var count = ref[0];
    var set = ref[1];
    return {
      count: count,
      set: set,
      inc: function (number) {
        if ( number === void 0 ) number = 1;

        return set(add(number));
    },
      dec: function (number) {
        if ( number === void 0 ) number = 1;

        return set(add(-number));
    },
      reset: function () { return set(initial); }
    };
  };

  var useHover = function () {
    var ref = React.useState(false);
    var hovered = ref[0];
    var set = ref[1];
    return {
      hovered: hovered,
      bind: {
        onMouseEnter: function () { return set(true); },
        onMouseLeave: function () { return set(false); }
      }
    };
  };

  var useActive = function () {
    var ref = React.useState(false);
    var active = ref[0];
    var set = ref[1];
    return {
      active: active,
      bind: {
        onMouseDown: function () { return set(true); },
        onMouseUp: function () { return set(false); }
      }
    };
  };

  var useFocus = function () {
    var ref = React.useState(false);
    var focused = ref[0];
    var set = ref[1];
    return {
      focused: focused,
      bind: {
        onFocus: function () { return set(true); },
        onBlur: function () { return set(false); }
      }
    };
  };

  var useTouch = function () {
    var ref = React.useState(false);
    var touched = ref[0];
    var set = ref[1];
    return {
      touched: touched,
      bind: {
        onTouchStart: function () { return set(true); },
        onTouchEnd: function () { return set(false); }
      }
    };
  };

  var useList = function (initial) {
    if ( initial === void 0 ) initial = [];

    var ref = React.useState(initial);
    var list = ref[0];
    var set = ref[1];
    return {
      list: list,
      set: set,
      reset: function () { return set(initial); },
      push: function () {
        var values = [], len = arguments.length;
        while ( len-- ) values[ len ] = arguments[ len ];

        return set(function (prev) { return prev.concat( values); });
    },
      sort: function (fn) { return set(function (prev) { return [].concat( prev ).sort(fn); }); },
      filter: function (fn) { return set(function (prev) { return prev.filter(fn); }); }
    };
  };

  function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

  var useMap = function (initial) {
    if ( initial === void 0 ) initial = {};

    var ref = React.useState(initial);
    var values = ref[0];
    var set = ref[1];
    return {
      values: values,
      reset: function () { return set(initial); },
      clear: function () { return set({}); },
      get: function (key) { return values[key]; },
      has: function (key) { return Object.prototype.hasOwnProperty.call(values, key); },
      del: function (key) { return set(function (ref) {
        var rest$1 = objectWithoutProperties( ref, [String(key)] );
        var rest = rest$1;

        return rest;
        }); },
      set: function (key, updater) { return set(function (prev) {
        var obj;

        return (Object.assign({}, prev,
        ( obj = {}, obj[key] = typeof updater === 'function' ? updater(prev[key]) : updater, obj )));
        }); }
    };
  };

  var useField = function (initial) {
    var ref = React.useState(initial);
    var value = ref[0];
    var set = ref[1];
    return {
      value: value,
      set: set,
      reset: function () { return set(initial); },
      bind: {
        value: value,
        onChange: function (e) { return set(e.target.value); }
      }
    };
  };

  var cancelablePromise =
  /* istanbul ignore next */
  function (promise) {
    var hasCanceled = false;
    var wrappedPromise = new Promise(function (resolve, reject) {
      promise.then(function (val) { return hasCanceled ? reject({
        isCanceled: true
      }) : resolve(val); });
      promise.catch(function (error) { return hasCanceled ? reject({
        isCanceled: true
      }) : reject(error); });
    });
    return {
      promise: wrappedPromise,

      cancel: function cancel() {
        hasCanceled = true;
      }

    };
  };
  var hasOwn =
  /* istanbul ignore next */
  Object.prototype.hasOwnProperty;

  var is =
  /* istanbul ignore next */
  function (x, y) {
    if (x === y) {
      return x !== 0 || y !== 0 || 1 / x === 1 / y;
    }

    return x !== x && y !== y; // eslint-disable-line
  };

  var shallowEqual$1 =
  /* istanbul ignore next */
  function (objA, objB) {
    if (is(objA, objB)) { return true; }

    if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
      return false;
    }

    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) { return false; }

    for (var i = 0; i < keysA.length; i++) {
      //eslint-disable-line
      if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }

    return true;
  };
  var identity = function (x) { return x; };

  var useMergeState = function (initial) {
    if ( initial === void 0 ) initial = {};

    var ref = React.useState(initial);
    var state = ref[0];
    var set = ref[1];
    return {
      state: state,
      set: function (updater) { return set(function (prev) { return typeof updater === 'function' ? Object.assign({}, prev,
        updater(prev)) : Object.assign({}, prev,
        updater); }); }
    };
  };

  var useFetch = function (initialUrl, initialOptions, ref) {
    if ( initialOptions === void 0 ) initialOptions = {};
    if ( ref === void 0 ) ref = {};
    var onMount = ref.onMount; if ( onMount === void 0 ) onMount = true;
    var onResponse = ref.onResponse; if ( onResponse === void 0 ) onResponse = function () {};

    var ref$1 = React.useState({
      url: initialUrl,
      options: initialOptions
    });
    var config = ref$1[0];
    var setConfig = ref$1[1];
    var ref$2 = useMergeState({
      loading: true,
      data: null,
      error: null
    });
    var state = ref$2.state;
    var set = ref$2.set;
    var canFetchRef = React.useRef(onMount);
    React.useEffect(function () {
      var url = config.url;
      var options = config.options;

      if (!canFetchRef.current) {
        canFetchRef.current = true;
        return;
      }

      var cancelable = cancelablePromise(fetch(url, options));
      set({
        loading: true
      });
      cancelable.promise.then(function (res) { return res.json(); }).then(function (newData) {
        set(function (ref) {
          var error = ref.error;

          onResponse(error, newData);
          return {
            data: newData,
            loading: false
          };
        });
        return newData;
      }).catch(function (e) {
        set(function (ref) {
          var data = ref.data;

          onResponse(e, data);
          return {
            error: e,
            loading: false
          };
        });
        return e;
      });
      return function () { return cancelable.cancel(); }; // eslint-disable-line
    }, [config.url, config.options]);

    var updateConfig = function (key) { return function (updater) { return setConfig(function (prev) {
      var obj;

      var updated = typeof updater === 'function' ? updater(prev[key]) : updater; // make sure not to re-fetch data when updated is shallow equal to prev[key]

      if (shallowEqual$1(updated, prev[key])) {
        return prev;
      }

      return Object.assign({}, prev,
        ( obj = {}, obj[key] = updated, obj ));
    }); }; };

    return {
      setUrl: updateConfig('url'),
      setOptions: updateConfig('options'),
      setData: function (updater) { return set(function (ref) {
        var data = ref.data;

        return typeof updater === 'function' ? {
        data: updater(data)
      } : {
        data: updater
      };
        }); },
      loading: state.loading,
      data: state.data,
      error: state.error,
      fetch: function (urlUpdater, optionsUpdater) { return setConfig(function (prev) { return ({
        url: typeof urlUpdater === 'function' ? urlUpdater(prev.url) : urlUpdater || prev.url,
        // change reference of optionsï¼Œ so that we can re-fetch data when call fetch
        options: typeof optionsUpdater === 'function' ? optionsUpdater(prev.options) : Object.assign({}, (optionsUpdater || prev.options))
      }); }); }
    };
  };

  var useOnlineStatus = function () {
    var ref = React.useState(navigator.onLine);
    var online = ref[0];
    var set = ref[1];

    var handleOnline = function () { return set(true); };

    var handleOffline = function () { return set(false); };

    React.useEffect(function () {
      window.addEventListener('online', handleOnline);
      window.addEventListener('offline', handleOffline);
      return function () {
        window.removeEventListener('online', handleOnline);
        window.removeEventListener('offline', handleOffline);
      };
    }, []);
    return {
      online: online
    };
  };

  var useDidMount = function (f) { return React.useEffect(function () { return f && f(); }, []); };

  var useDidUpdate = function (f, conditions) {
    var didMountRef = React.useRef(false);
    React.useEffect(function () {
      if (!didMountRef.current) {
        didMountRef.current = true;
        return;
      } // Cleanup effects when f returns a function


      return f && f(); //eslint-disable-line
    }, conditions);
  };

  var useWillUnmount = function (f) { return React.useEffect(function () { return function () { return f && f(); }; }, []); };

  var createGlobalState = function (initial) {
    if ( initial === void 0 ) initial = {};

    var state = initial;
    var listeners = [];

    var getState = function () { return state; };

    var subscribe = function (f) {
      if ( f === void 0 ) f = identity;

      listeners.push(f);
      return function () {
        listeners = listeners.filter(function (l) { return l !== f; });
      };
    };

    var set = function (updater) {
      if (typeof updater === 'function') {
        state = updater(state);
      } else {
        state = updater;
      }

      listeners.forEach(function (f) { return f(state); });
    };

    var initialStore = {
      getState: getState,
      subscribe: subscribe,
      set: set
    };
    var context = React.createContext(initialStore);
    var Provider = context.Provider;
    var Consumer = context.Consumer;

    var GlobalProvider = function (ref) {
      var children = ref.children;

      return React__default.createElement( Provider, { value: initialStore },
        children
      );
    };

    var useStore = function () {
      var store = React.useContext(context);
      return store;
    };

    var useSelector = function (selector) {
      if ( selector === void 0 ) selector = identity;

      var initialValue = selector(state);
      var ref = React.useState(initialValue);
      var value = ref[0];
      var setValue = ref[1];
      React.useEffect(function () {
        var l = function (newState) {
          var newValue = selector(newState);

          if (newValue !== value) {
            setValue(newValue);
          }
        };

        var unsubscribe = subscribe(l);
        return unsubscribe;
      }, []);
      return value;
    };

    var useSet = function () { return set; };

    var useGlobalState = function () {
      var storeState = useSelector();
      return {
        set: set,
        state: storeState
      };
    };

    return {
      GlobalProvider: GlobalProvider,
      GlobalConsumer: Consumer,
      useStore: useStore,
      useGlobalState: useGlobalState,
      set: set,
      getState: getState,
      useSelector: useSelector,
      useSet: useSet
    };
  };

  var createContextState = function (initial) {
    if ( initial === void 0 ) initial = {};

    var globalState = createGlobalState(initial);
    return {
      ContextProvider: globalState.GlobalProvider,
      ContextConsumer: globalState.GlobalConsumer,
      set: globalState.set,
      useContextState: globalState.useGlobalState,
      getState: globalState.getState,
      useStore: globalState.useStore,
      useSelector: globalState.useSelector,
      useSet: globalState.useSet
    };
  };

  var useUndo = function (initial) {
    var ref = useMergeState({
      past: [],
      present: initial,
      future: []
    });
    var state = ref.state;
    var set = ref.set;

    var undo = function () {
      set(function (prevState) {
        var past = prevState.past;
        var present = prevState.present;
        var future = prevState.future;

        if (past.length === 0) {
          return prevState;
        }

        var previous = past[past.length - 1];
        return {
          past: past.slice(0, past.length - 1),
          present: previous,
          future: [present ].concat( future)
        };
      });
    };

    var redo = function () {
      set(function (prevState) {
        var past = prevState.past;
        var present = prevState.present;
        var future = prevState.future;

        if (future.length === 0) {
          return prevState;
        }

        var next = future[0];
        var restFuture = future.slice(1);
        return {
          past: past.concat( [present]),
          present: next,
          future: restFuture
        };
      });
    };

    var setPresent = function (updater) { return set(function (ref) {
      var present = ref.present;
      var past = ref.past;

      return ({
      past: past.concat( [present]),
      present: typeof updater === 'function' ? updater(present) : updater,
      future: []
    });
      }); };

    return Object.assign({}, state,
      {undo: undo,
      redo: redo,
      set: setPresent});
  };

  var useStateCallback = function (initialState, f) {
    var ref = React.useState(initialState);
    var state = ref[0];
    var set = ref[1];
    useDidUpdate(f, [state]);
    return {
      state: state,
      set: set
    };
  };

  var isShallowEqual = function (depsA, depsB) {
    if ( depsA === void 0 ) depsA = [];
    if ( depsB === void 0 ) depsB = [];

    if (depsA.length !== depsB.length) {
      return false;
    }

    return depsA.every(function (a, index) { return shallowEqual(a, depsB[index]); });
  };

  var useEqualEffect = function (compareFn, f, deps) {
    var ref = React.useRef([]);

    if (!compareFn(ref.current, deps)) {
      ref.current = deps;
    }

    React.useEffect(f, ref.current);
  };

  var useShallowEqualEffect = function (f, deps) {
    useEqualEffect(isShallowEqual, f, deps);
  };
  var useDeepEqualEffect = function (f, deps) {
    useEqualEffect(deepEqual, f, deps);
  };

  exports.useToggle = useToggle;
  exports.useCounter = useCounter;
  exports.useHover = useHover;
  exports.useActive = useActive;
  exports.useFocus = useFocus;
  exports.useTouch = useTouch;
  exports.useList = useList;
  exports.useMap = useMap;
  exports.useField = useField;
  exports.useFetch = useFetch;
  exports.useMergeState = useMergeState;
  exports.useOnlineStatus = useOnlineStatus;
  exports.useDidMount = useDidMount;
  exports.useDidUpdate = useDidUpdate;
  exports.useWillUnmount = useWillUnmount;
  exports.createGlobalState = createGlobalState;
  exports.createContextState = createContextState;
  exports.useUndo = useUndo;
  exports.useStateCallback = useStateCallback;
  exports.useShallowEqualEffect = useShallowEqualEffect;
  exports.useDeepEqualEffect = useDeepEqualEffect;

})));
