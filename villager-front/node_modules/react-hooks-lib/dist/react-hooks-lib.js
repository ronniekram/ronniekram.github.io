function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var shallowEqual = _interopDefault(require('shallowequal'));
var deepEqual = _interopDefault(require('lodash.isequal'));

var useToggle = function (initial) {
  if ( initial === void 0 ) initial = false;

  var ref = React.useState(initial);
  var on = ref[0];
  var setToggle = ref[1];
  return {
    on: on,
    set: setToggle,
    reset: function () { return setToggle(initial); },
    toggle: function () { return setToggle(function (prev) { return !prev; }); }
  };
};

var add = function (value) { return function (prev) { return prev + value; }; };

var useCounter = function (initial) {
  if ( initial === void 0 ) initial = 0;

  var ref = React.useState(initial);
  var count = ref[0];
  var set = ref[1];
  return {
    count: count,
    set: set,
    inc: function (number) {
      if ( number === void 0 ) number = 1;

      return set(add(number));
  },
    dec: function (number) {
      if ( number === void 0 ) number = 1;

      return set(add(-number));
  },
    reset: function () { return set(initial); }
  };
};

var useHover = function () {
  var ref = React.useState(false);
  var hovered = ref[0];
  var set = ref[1];
  return {
    hovered: hovered,
    bind: {
      onMouseEnter: function () { return set(true); },
      onMouseLeave: function () { return set(false); }
    }
  };
};

var useActive = function () {
  var ref = React.useState(false);
  var active = ref[0];
  var set = ref[1];
  return {
    active: active,
    bind: {
      onMouseDown: function () { return set(true); },
      onMouseUp: function () { return set(false); }
    }
  };
};

var useFocus = function () {
  var ref = React.useState(false);
  var focused = ref[0];
  var set = ref[1];
  return {
    focused: focused,
    bind: {
      onFocus: function () { return set(true); },
      onBlur: function () { return set(false); }
    }
  };
};

var useTouch = function () {
  var ref = React.useState(false);
  var touched = ref[0];
  var set = ref[1];
  return {
    touched: touched,
    bind: {
      onTouchStart: function () { return set(true); },
      onTouchEnd: function () { return set(false); }
    }
  };
};

var useList = function (initial) {
  if ( initial === void 0 ) initial = [];

  var ref = React.useState(initial);
  var list = ref[0];
  var set = ref[1];
  return {
    list: list,
    set: set,
    reset: function () { return set(initial); },
    push: function () {
      var values = [], len = arguments.length;
      while ( len-- ) values[ len ] = arguments[ len ];

      return set(function (prev) { return prev.concat( values); });
  },
    sort: function (fn) { return set(function (prev) { return [].concat( prev ).sort(fn); }); },
    filter: function (fn) { return set(function (prev) { return prev.filter(fn); }); }
  };
};

function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }

var useMap = function (initial) {
  if ( initial === void 0 ) initial = {};

  var ref = React.useState(initial);
  var values = ref[0];
  var set = ref[1];
  return {
    values: values,
    reset: function () { return set(initial); },
    clear: function () { return set({}); },
    get: function (key) { return values[key]; },
    has: function (key) { return Object.prototype.hasOwnProperty.call(values, key); },
    del: function (key) { return set(function (ref) {
      var rest$1 = objectWithoutProperties( ref, [String(key)] );
      var rest = rest$1;

      return rest;
      }); },
    set: function (key, updater) { return set(function (prev) {
      var obj;

      return (Object.assign({}, prev,
      ( obj = {}, obj[key] = typeof updater === 'function' ? updater(prev[key]) : updater, obj )));
      }); }
  };
};

var useField = function (initial) {
  var ref = React.useState(initial);
  var value = ref[0];
  var set = ref[1];
  return {
    value: value,
    set: set,
    reset: function () { return set(initial); },
    bind: {
      value: value,
      onChange: function (e) { return set(e.target.value); }
    }
  };
};

var cancelablePromise =
/* istanbul ignore next */
function (promise) {
  var hasCanceled = false;
  var wrappedPromise = new Promise(function (resolve, reject) {
    promise.then(function (val) { return hasCanceled ? reject({
      isCanceled: true
    }) : resolve(val); });
    promise.catch(function (error) { return hasCanceled ? reject({
      isCanceled: true
    }) : reject(error); });
  });
  return {
    promise: wrappedPromise,

    cancel: function cancel() {
      hasCanceled = true;
    }

  };
};
var hasOwn =
/* istanbul ignore next */
Object.prototype.hasOwnProperty;

var is =
/* istanbul ignore next */
function (x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  }

  return x !== x && y !== y; // eslint-disable-line
};

var shallowEqual$1 =
/* istanbul ignore next */
function (objA, objB) {
  if (is(objA, objB)) { return true; }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) { return false; }

  for (var i = 0; i < keysA.length; i++) {
    //eslint-disable-line
    if (!hasOwn.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
};
var identity = function (x) { return x; };

var useMergeState = function (initial) {
  if ( initial === void 0 ) initial = {};

  var ref = React.useState(initial);
  var state = ref[0];
  var set = ref[1];
  return {
    state: state,
    set: function (updater) { return set(function (prev) { return typeof updater === 'function' ? Object.assign({}, prev,
      updater(prev)) : Object.assign({}, prev,
      updater); }); }
  };
};

var useFetch = function (initialUrl, initialOptions, ref) {
  if ( initialOptions === void 0 ) initialOptions = {};
  if ( ref === void 0 ) ref = {};
  var onMount = ref.onMount; if ( onMount === void 0 ) onMount = true;
  var onResponse = ref.onResponse; if ( onResponse === void 0 ) onResponse = function () {};

  var ref$1 = React.useState({
    url: initialUrl,
    options: initialOptions
  });
  var config = ref$1[0];
  var setConfig = ref$1[1];
  var ref$2 = useMergeState({
    loading: true,
    data: null,
    error: null
  });
  var state = ref$2.state;
  var set = ref$2.set;
  var canFetchRef = React.useRef(onMount);
  React.useEffect(function () {
    var url = config.url;
    var options = config.options;

    if (!canFetchRef.current) {
      canFetchRef.current = true;
      return;
    }

    var cancelable = cancelablePromise(fetch(url, options));
    set({
      loading: true
    });
    cancelable.promise.then(function (res) { return res.json(); }).then(function (newData) {
      set(function (ref) {
        var error = ref.error;

        onResponse(error, newData);
        return {
          data: newData,
          loading: false
        };
      });
      return newData;
    }).catch(function (e) {
      set(function (ref) {
        var data = ref.data;

        onResponse(e, data);
        return {
          error: e,
          loading: false
        };
      });
      return e;
    });
    return function () { return cancelable.cancel(); }; // eslint-disable-line
  }, [config.url, config.options]);

  var updateConfig = function (key) { return function (updater) { return setConfig(function (prev) {
    var obj;

    var updated = typeof updater === 'function' ? updater(prev[key]) : updater; // make sure not to re-fetch data when updated is shallow equal to prev[key]

    if (shallowEqual$1(updated, prev[key])) {
      return prev;
    }

    return Object.assign({}, prev,
      ( obj = {}, obj[key] = updated, obj ));
  }); }; };

  return {
    setUrl: updateConfig('url'),
    setOptions: updateConfig('options'),
    setData: function (updater) { return set(function (ref) {
      var data = ref.data;

      return typeof updater === 'function' ? {
      data: updater(data)
    } : {
      data: updater
    };
      }); },
    loading: state.loading,
    data: state.data,
    error: state.error,
    fetch: function (urlUpdater, optionsUpdater) { return setConfig(function (prev) { return ({
      url: typeof urlUpdater === 'function' ? urlUpdater(prev.url) : urlUpdater || prev.url,
      // change reference of optionsï¼Œ so that we can re-fetch data when call fetch
      options: typeof optionsUpdater === 'function' ? optionsUpdater(prev.options) : Object.assign({}, (optionsUpdater || prev.options))
    }); }); }
  };
};

var useOnlineStatus = function () {
  var ref = React.useState(navigator.onLine);
  var online = ref[0];
  var set = ref[1];

  var handleOnline = function () { return set(true); };

  var handleOffline = function () { return set(false); };

  React.useEffect(function () {
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    return function () {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);
  return {
    online: online
  };
};

var useDidMount = function (f) { return React.useEffect(function () { return f && f(); }, []); };

var useDidUpdate = function (f, conditions) {
  var didMountRef = React.useRef(false);
  React.useEffect(function () {
    if (!didMountRef.current) {
      didMountRef.current = true;
      return;
    } // Cleanup effects when f returns a function


    return f && f(); //eslint-disable-line
  }, conditions);
};

var useWillUnmount = function (f) { return React.useEffect(function () { return function () { return f && f(); }; }, []); };

var createGlobalState = function (initial) {
  if ( initial === void 0 ) initial = {};

  var state = initial;
  var listeners = [];

  var getState = function () { return state; };

  var subscribe = function (f) {
    if ( f === void 0 ) f = identity;

    listeners.push(f);
    return function () {
      listeners = listeners.filter(function (l) { return l !== f; });
    };
  };

  var set = function (updater) {
    if (typeof updater === 'function') {
      state = updater(state);
    } else {
      state = updater;
    }

    listeners.forEach(function (f) { return f(state); });
  };

  var initialStore = {
    getState: getState,
    subscribe: subscribe,
    set: set
  };
  var context = React.createContext(initialStore);
  var Provider = context.Provider;
  var Consumer = context.Consumer;

  var GlobalProvider = function (ref) {
    var children = ref.children;

    return React__default.createElement( Provider, { value: initialStore },
      children
    );
  };

  var useStore = function () {
    var store = React.useContext(context);
    return store;
  };

  var useSelector = function (selector) {
    if ( selector === void 0 ) selector = identity;

    var initialValue = selector(state);
    var ref = React.useState(initialValue);
    var value = ref[0];
    var setValue = ref[1];
    React.useEffect(function () {
      var l = function (newState) {
        var newValue = selector(newState);

        if (newValue !== value) {
          setValue(newValue);
        }
      };

      var unsubscribe = subscribe(l);
      return unsubscribe;
    }, []);
    return value;
  };

  var useSet = function () { return set; };

  var useGlobalState = function () {
    var storeState = useSelector();
    return {
      set: set,
      state: storeState
    };
  };

  return {
    GlobalProvider: GlobalProvider,
    GlobalConsumer: Consumer,
    useStore: useStore,
    useGlobalState: useGlobalState,
    set: set,
    getState: getState,
    useSelector: useSelector,
    useSet: useSet
  };
};

var createContextState = function (initial) {
  if ( initial === void 0 ) initial = {};

  var globalState = createGlobalState(initial);
  return {
    ContextProvider: globalState.GlobalProvider,
    ContextConsumer: globalState.GlobalConsumer,
    set: globalState.set,
    useContextState: globalState.useGlobalState,
    getState: globalState.getState,
    useStore: globalState.useStore,
    useSelector: globalState.useSelector,
    useSet: globalState.useSet
  };
};

var useUndo = function (initial) {
  var ref = useMergeState({
    past: [],
    present: initial,
    future: []
  });
  var state = ref.state;
  var set = ref.set;

  var undo = function () {
    set(function (prevState) {
      var past = prevState.past;
      var present = prevState.present;
      var future = prevState.future;

      if (past.length === 0) {
        return prevState;
      }

      var previous = past[past.length - 1];
      return {
        past: past.slice(0, past.length - 1),
        present: previous,
        future: [present ].concat( future)
      };
    });
  };

  var redo = function () {
    set(function (prevState) {
      var past = prevState.past;
      var present = prevState.present;
      var future = prevState.future;

      if (future.length === 0) {
        return prevState;
      }

      var next = future[0];
      var restFuture = future.slice(1);
      return {
        past: past.concat( [present]),
        present: next,
        future: restFuture
      };
    });
  };

  var setPresent = function (updater) { return set(function (ref) {
    var present = ref.present;
    var past = ref.past;

    return ({
    past: past.concat( [present]),
    present: typeof updater === 'function' ? updater(present) : updater,
    future: []
  });
    }); };

  return Object.assign({}, state,
    {undo: undo,
    redo: redo,
    set: setPresent});
};

var useStateCallback = function (initialState, f) {
  var ref = React.useState(initialState);
  var state = ref[0];
  var set = ref[1];
  useDidUpdate(f, [state]);
  return {
    state: state,
    set: set
  };
};

var isShallowEqual = function (depsA, depsB) {
  if ( depsA === void 0 ) depsA = [];
  if ( depsB === void 0 ) depsB = [];

  if (depsA.length !== depsB.length) {
    return false;
  }

  return depsA.every(function (a, index) { return shallowEqual(a, depsB[index]); });
};

var useEqualEffect = function (compareFn, f, deps) {
  var ref = React.useRef([]);

  if (!compareFn(ref.current, deps)) {
    ref.current = deps;
  }

  React.useEffect(f, ref.current);
};

var useShallowEqualEffect = function (f, deps) {
  useEqualEffect(isShallowEqual, f, deps);
};
var useDeepEqualEffect = function (f, deps) {
  useEqualEffect(deepEqual, f, deps);
};

exports.useToggle = useToggle;
exports.useCounter = useCounter;
exports.useHover = useHover;
exports.useActive = useActive;
exports.useFocus = useFocus;
exports.useTouch = useTouch;
exports.useList = useList;
exports.useMap = useMap;
exports.useField = useField;
exports.useFetch = useFetch;
exports.useMergeState = useMergeState;
exports.useOnlineStatus = useOnlineStatus;
exports.useDidMount = useDidMount;
exports.useDidUpdate = useDidUpdate;
exports.useWillUnmount = useWillUnmount;
exports.createGlobalState = createGlobalState;
exports.createContextState = createContextState;
exports.useUndo = useUndo;
exports.useStateCallback = useStateCallback;
exports.useShallowEqualEffect = useShallowEqualEffect;
exports.useDeepEqualEffect = useDeepEqualEffect;
